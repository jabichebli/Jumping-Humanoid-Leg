%------------------------------------------------------------------------
%------------------------------------------------------------------------
% MECENG239 Final Project - Hopping Leg  (+ Front Flip as extension)
% Course: ME239: Robotic Locomotion
% Semester: Fall 2025
%------------------------------------------------------------------------
% By: Jason Abi Chebli
% Student ID: 3042017306
% Last Modified: 2025-09-17
% The following is the MATLAB code used to determine the dynamics of a
% robotic leg jumping up and down. 
%------------------------------------------------------------------------
%------------------------------------------------------------------------

clear all; close all; clc;

% ---------------------------- Symbolic Setup -----------------------------
% Define Symbolic Variables for 2-link leg system
syms x y q1 q2 real
syms xdot ydot q1dot q2dot real
syms xddot yddot q1ddot q2ddot real
syms m1 I1 l1 d1 m2 I2 l2 d2 g real
syms q1 q2 real

% Generalized coords and rates

% Pi = sym(pi) ;
Pi = 3.14;

q1 = 240*Pi/180;
q2 = Pi/180 ;
xdot = 0 ;
ydot = 0;
q1dot = 0 ;
q2dot = 0 ;


% Leg properties
m1 = 0.05; % mass of link 1, kg
I1 = 0.0001; % moment of inertia of link 1, m^4
l1 = 0.12; % length of link 1, m
d1 = 0.06; % absolute distance to COM of link 1, m

m2 = 0.5; % mass of link 2, kg
I2 = 0.000053; % moment of inertia of link 2, m^4
l2 = 0.08; % length of link 2, m
d2 = 0.04; % absolute distance to COM of link 2, m

x = 0;
y = sin(Pi/3)*l2+ cos(Pi/3)*l1;

% q0 = [deg2rad(15);
%       deg2rad(0)] ;
% 
% dq0 = zeros(2,1) ;
% x0 = [q0;
%       dq0] ;

% x = [x ; y ; dx ; dy] ;


q  = [x; y; q1; q2];
dq = [xdot; ydot; q1dot; q2dot];
ddq = [xddot; yddot; q1ddot; q2ddot];

% x = [q ; dq] ;


g = 9.81; % gravity, m/s^2



% -------------------------------------------------------------------------
% ------------------------- Dynamics Functions ----------------------------
% -------------------------------------------------------------------------
function dx = double_pendulum(t, x)
    q = x(1:2) ; dq = x(3:4) ;
    x = q(1) ; y = q(2) ; th1 = q(3) ; th2 = q(4) ;
    dx = dq(1) ; dy = dq(2) ; dth1 = dq(3) ; dth2 = dq(4) ;

    % Leg properties
    m1 = 0.05; % mass of link 1, kg
    I1 = 0.0001; % moment of inertia of link 1, m^4
    l1 = 0.12; % length of link 1, m
    d1 = 0.06; % absolute distance to COM of link 1, m
    
    m2 = 0.5; % mass of link 2, kg
    I2 = 0.000053; % moment of inertia of link 2, m^4
    l2 = 0.08; % length of link 2, m
    d2 = 0.04; % absolute distance to COM of link 2, m

    D = auto_D(I1,I2,d1,d2,l1,m1,m2,q1,q2) ;
    C = auto_C(d1,d2,l1,m1,m2,q1,q2,q1dot,q2dot) ;
    G = auto_G(d1,d2,g,l1,m1,m2,q1,q2) ;
    B = auto_B ;
    
    Jst = auto_Jst(l1,l2,q1,q2) ;
    Jstdot = auto_Jstdot(l1,l2,q1,q2,q1dot,q2dot) ;

    LHS = [D, -Jst.';
        Jst, zeros(2,2)] ;

    RHS = [-C * dq - G + B * [0,0].';
        -Jstdot] ;
    
    d2q_tauc = LHS \ RHS;
    d2q = d2q_tauc(1:2) ;
    end




% 
% % ---------------------------- During Impact ------------------------------
% function [dq_plus, Lambda] = impact_dynamics(q, dq_minus, D, Jst)
%     % Inputs:
%     %   q: Generalized coordinates
%     %   dq_minus: Pre-impact generalized velocities
%     %   D: Inertia matrix
%     %   Jst: Stance Jacobian (partial_pfoot/partial_q) at impact
%     %
%     % Outputs:
%     %   dq_plus: Post-impact generalized velocities
%     %   Lambda: Contact impulse at impact
% 
%     % Assemble the block system
%     A = [D, -Jst.'; 
%          Jst, zeros(size(Jst,1))];
% 
%     % Right-hand side
%     b = [D*dq_minus; 
%          zeros(size(Jst,1),1)];
% 
%     % Solve for [dq_plus; Lambda]
%     sol = A \ b;
%     dq_plus = simplify(sol(1:length(q)));
%     Lambda  = simplify(sol(length(q)+1:end));
% end


% % ---------- Inverse Kinematics Problem (with COM Constraint) ------------- 
% % Assume the foot is at (0,0) in a world frame
% eq1 = (x_hip + l1*sin(q1) + l2*sin(q1 + q2)) == 0; %xf = 0 
% eq2 = (y_hip + l1*cos(q1) + l2*cos(q1 + q2)) == 0; %yf = 0 
% eq3 = (m1*(x_hip + d1*sin(q1)) + m2*(x_hip + l1*sin(q1) + d2*sin(q1 + q2))) / (m1 + m2) == 0; %pCOM_x = 0
% 
% % Solve the system for the unknowns x_hip, q1, and q2
% solutions = solve([eq1, eq2, eq3], [x_hip, q1, q2], 'Real', true);
% x_hip_sym = solutions.x_hip;
% q1_sym = solutions.q1;
% q2_sym = solutions.q2;
% 
% % Convert the symbolic solution to a fast MATLAB function
% inv_kin_func = matlabFunction([x_hip_sym(1), q1_sym(1), q2_sym(1)], 'Vars', {y_hip, l1, l2, d1, d2, m1, m2});